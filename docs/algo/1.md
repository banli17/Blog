# 数据结构与算法

## 1

职业训练：拆分知识点、刻意练习、反馈(学习别人、被别人指点)

切题四件套(单个题目)：

-   Clarification: 多看题目，反复沟通，保证理解正确
-   Possible solutions: 列出所有可能的解法
    -   compare(time/space): 比较时空复杂度
    -   optimal(加强)：找最优
-   Coding 多些
-   Test Case: 测试用例

五步刷题法：

-   第一遍： 5 分钟读题+思考，没思路就直接看解法：注意！多解法，比较解法优劣。背诵
-   第二遍: 马上自己写 -> leetcode 提交；各种解法比较(执行时间)、体会 -> 优化！
-   第三遍: 过了一天后，练习
-   第四遍 : 够了一周后，练习
-   第五遍 : 面试前，练习

误区： 不要只练习一遍

https://naotu.baidu.com/file/b832f043e2ead159d584cca4efb19703?token=7a6a56eb2630548c
https://naotu.baidu.com/file/0a53d3a5343bd86375f348b2831d3610?token=5ab1de1c90d5f3ec

## 2-1 编辑器、代码风格

快捷键，google 代码风格 ，自顶向下代码

## 2-2 时间复杂度

大 O 表示法

```
O(1)
O(N)
O(N^2)
O(log(n))
O(K^n)
```

二叉树搜索：前序、中序、后序 O(n)
图的遍历 O(n)
搜索算法: DFS、BFS O(n)
二分查找 O(logn)
归并排序： O(nlogn)

-   如何理解算法时间复杂度的表示法https://www.zhihu.com/question/21387264
-   Master theorem http://en.wikipedia.org/wiki/Master_theorem_(analysis_of_algorithms)
-   主定理http://zh.wikipedia.org/wiki/%E4%B8%BB%E5%AE%9A%E7%90%86

## 3-1 数组、链表、跳表

Array 数组

特点
内存开辟连续的地址，可以通过内存管理器访问，时间复杂度都是 O(1)
问题：
插入时后面元素都要向后移动一位 O(n)
删除时将后面的元素往前移动一位 O(n)，最后一个设置为 null，唤起内存回收机制

ArrayList 支持扩容，如果容量不够，会新建一个 2 倍大小的数组，将旧的数组拷贝过去。
删除时也会移动位置。 删除、插入时间复杂度还是 O(n)

Array 时间复杂度

```
prepend    O(1)
append O(1)
lookup O(1)
insert O(n)
delete O(n)
```

Linked List

head
tail
next 指针，最后一个元素的 next 指向 None

双向链表， java 里的 LinkedList
循环链表

插入节点： O(1)
删除节点: O(1)
查找节点: O(n)

```
prepend  O(1)
append  O(1)
lookup  O(n)
insert  O(1)
delete  O(1)
```

跳表：为了优化链表的缺陷（随机访问某个元素的时间）

-   升维思想 多维空间
-   空间换时间

建立索引级别
索引的高度： logn，每层索引遍历的节点个数 3
在跳表中查询任意数据的时间复杂度就是 O(logn)

```
1                        第k 级索引
1       5
1   3   5   7
1 2 3 4 5 6 7 8 9
```

n/2 n/4 n/8 第 k 级索引节点个数是 n/(2^k)
假设索引有 h 级，最高级的索引有 2 个节点，n/(2^h) = 2 从而 h = log2(n) - 1

现实中跳表会随着增加和删除，索引跨步会改变，需要更新索引，维护索引成本高

空间复杂度
2 个节点抽 1 个 n/2 n/4 n/8 8 4 2
3 个抽一个 n/3 n/9 n/27 9 3 1
空间复杂度 O(n)

工程中的应用
LRU Cache - Linked List 146
