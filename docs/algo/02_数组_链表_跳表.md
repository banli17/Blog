---
title: "数组、链表、跳表"
---

# 数组、链表、跳表

## 概念

**Array 数组**

数组的特点是开辟一段内存连续的地址，可以通过硬件内存管理器来访问，它可以保证访问某个元素的时间复杂度都是 O(1)。

数组存在的问题：

-   插入时后面元素都要向后移动一位 O(n)
-   删除时将后面的元素往前移动一位 O(n)，最后一个设置为 null，唤起内存回收机制

ArrayList 支持扩容，如果容量不够，会新建一个 2 倍大小的数组，将旧的数组拷贝过去。删除时也会移动位置。 删除、插入时间复杂度还是 O(n)。

所以 Array 时间复杂度为：

```
prepend    O(1)
append O(1)
lookup O(1)
insert O(n)
delete O(n)
```

链表出现是为了解决数组的插入和删除操作时间复杂度高的问题。它的特点是：

-   有头 head、尾 tail 节点。
-   节点有 next 指针指向下一个元素，最后一个元素的 next 指针指向 None。

时间复杂度分析：

-   插入: 只需要将前一个节点的 next 指向插入元素，插入元素的 next 指针指向下一个节点即可。时间复杂度是 O(1)。
-   删除: 前一个节点的 next 指向要删除元素的下个节点。时间复杂度是 O(1)。
-   查找：时间复杂度为 O(n)。

双向链表， java 里的 LinkedList
循环链表

插入节点： O(1)
删除节点: O(1)
查找节点: O(n)

```
prepend  O(1)
append  O(1)
lookup  O(n)
insert  O(1)
delete  O(1)
```

跳表：为了优化链表的缺陷（随机访问某个元素的时间太长 O(n）)。

跳表的思想是：

-   升维思想，多维空间
-   空间换时间

建立索引级别
索引的高度： logn，每层索引遍历的节点个数 3
在跳表中查询任意数据的时间复杂度就是 O(logn)

```
1                        第k 级索引
1       5
1   3   5   7
1 2 3 4 5 6 7 8 9
```

n/2 n/4 n/8 第 k 级索引节点个数是 n/(2^k)
假设索引有 h 级，最高级的索引有 2 个节点，n/(2^h) = 2 从而 h = log2(n) - 1

现实中跳表会随着增加和删除，索引跨步会改变，需要更新索引，维护索引成本高

空间复杂度
2 个节点抽 1 个 n/2 n/4 n/8 8 4 2
3 个抽一个 n/3 n/9 n/27 9 3 1
空间复杂度 O(n)

工程中的应用
LRU Cache - Linked List 146

## 题目

### 283.Move Zeroes

题目：[https://leetcode-cn.com/problems/move-zeroes/](https://leetcode-cn.com/problems/move-zeroes/)

-   罗列解法
    1. 第一次循环将非 0 移动到前面，第二次循环后面 0
    2. 一次循环，交换位置
    3. 一次循环，将前面的值设置为当前值，当前位置设置为 0

```py
# 解法1
def move_zero(nums):
    i = 0
    for l in nums:
        if l != 0:
            nums[i] = l
            i += 1
    for x in range(i, len(nums)):
        nums[x] = 0
    return nums

# 解法2
def move_zero(nums):
    i = 0
    for n in range(len(nums)):
        if nums[n] != 0:
            nums[n], nums[i] = nums[i], nums[n]
            i += 1
    return nums

# 解法3
def move_zero(nums):
    i = -1
    for n in range(len(nums)):
        if nums[n] != 0:
            i += 1
            nums[i] = nums[n]
            if (i != n):
                nums[n] = 0
    return nums
```

### 11.装最多水问题

题目：[https://leetcode-cn.com/problems/container-with-most-water/](https://leetcode-cn.com/problems/container-with-most-water/)

-   解法
    -   暴力法，两层循环求最大值 O(n^2)，第二层循环从 i+1 开始
    -   两边收敛(左右夹逼)法，一层循环，两个指针往里收，如果比外层高度小不用考虑，高度大才比较。

```py
class Solution(object):
    # 暴力法，时间太长，未通过
    def maxArea(self, height):
        oldArea = 0
        for i in range(0, len(height) - 1):
            for j in range(i + 1, len(height) - 1):
                area = min(height[j], height[i]) * (j - i)
                if area > oldArea:
                    oldArea = area
        return oldArea

    # 收敛法
    def maxArea2(self, height):
        i = 0
        j = len(height) - 1
        r = 0
        minHeight = 0
        while i < j:
            if height[i] < height[j]:
                minHeight = height[i]
                i += 1
            else:
                minHeight = height[j]
                j -= 1
            area = (j - i + 1) * minHeight
            r = max(area, r)
        return r

s = Solution()
print(s.maxArea2([1,8,6,2,5,4,8,3,7]))
```

### 70.爬楼梯问题

题目：[https://leetcode-cn.com/problems/climbing-stairs/](https://leetcode-cn.com/problems/climbing-stairs/)

-   解法
    -   暴力? 不行
    -   找重复子问题，斐波拉契

```py
# 递推法，用3个变量不断前进
class Solution(object):
    def climbStairs(self, n):
        if n <= 2:
            return n
        f1, f2, f3 = 1, 2, 3
        for i in range(3, n+1):
            f3 = f1 + f2
            f1 = f2
            f2 = f3
        return f3
```

### 1.两数之和

```py
# https://leetcode-cn.com/problems/two-sum/

# 暴力法 两层循环

class Solution(object):
    def twoSum(self, nums, target):
        nums_len = len(nums)
        for i in range(nums_len):
            for j in range(i+1, nums_len):
                if target == nums[i] + nums[j]:
                    return [i, j]

nums = [2, 7, 11, 15]
target = 9
s = Solution()
r = s.twoSum(nums, target)
print(r)
```

### 15. 三数之和

```py
# https://leetcode-cn.com/problems/3sum/
# 和第1题类似， a + b = -c
# 解法：
# - 暴力，三层循环 O(n^3)
# - hash表，O(n^2)， 循环两次，去哈希表里查结果 c
# - 左右夹逼 O(NlogN)，先排序，再 k i j，i j 往中间走
class Solution(object):
    def threeSum(self, nums):
        list_r = []
        nums.sort()
        for i in range(0, len(nums)):
            for j in range((i + 1), len(nums)):
                for k in range((j + 1), len(nums)):
                    if (nums[i] + nums[j] + nums[k] == 0) and ([nums[i], nums[j], nums[k]] not in list_r):
                        list_r.append([nums[i], nums[j], nums[k]])
        return list_r

    def threeSum3(self, nums):
        list_r = []
        nums.sort()
        for k in range(0, len(nums)):
            i = k + 1
            j = len(nums) - 1
            while i < j:
                nums_sum = nums[k] + nums[i] + nums[j]
                if nums_sum == 0:
                    # if [nums[i], nums[j], nums[k]] not in list_r:
                    list_r.append([nums[i], nums[j], nums[k]])
                    while(i<j and nums[i]==nums[i+1]):
                        i += 1
                    while(i<j and nums[j]==nums[j-1]):
                        j-=1
                    i += 1
                    j -= 1
                elif nums_sum < 0:
                    i += 1
                else:
                    j -= 1
        return list_r


s = Solution()

r = s.threeSum3([-1,0,1,2,-1,-4])
print(r)
```

## 资料

**课后作业**

-   https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/
-   https://leetcode-cn.com/problems/rotate-array/
-   https://leetcode-cn.com/problems/merge-two-sorted-lists/
-   https://leetcode-cn.com/problems/merge-sorted-array/
-   https://leetcode-cn.com/problems/two-sum/
-   https://leetcode-cn.com/problems/move-zeroes/
-   https://leetcode-cn.com/problems/plus-one/

**Linked List 实战题目**

-   https://leetcode.com/problems/reverse-linked-list/
-   https://leetcode.com/problems/swap-nodes-in-pairs
-   https://leetcode.com/problems/linked-list-cycle
-   https://leetcode.com/problems/linked-list-cycle-ii
-   https://leetcode.com/problems/reverse-nodes-in-k-group/

练习题：

1. https://leetcode.com/problems/reverse-linked-list/ 206

-   方法 1 迭代法
-   方法 2 递归
-   方法 3 es6 https://leetcode.com/problems/reverse-linked-list/discuss/313728/Javascript-ES6-less-code-solution

2. https://leetcode.com/problems/linked-list-cycle 141

新建节点进行迭代：https://leetcode.com/problems/swap-nodes-in-pairs/discuss/284762/js-solution-faster-than-100

-   暴力法，循环等 1s 没相遇就没有环
-   将前面节点记录一下，然后查找。
-   快慢指针: https://leetcode.com/problems/linked-list-cycle/discuss/371507/Javascript-Solutions-(using-Set-slow-and-fast-pointers)

3. https://leetcode.com/problems/swap-nodes-in-pairs 24

-   加一个头节点，防止赋值导致节点断裂的问题

4. https://leetcode.com/problems/linked-list-cycle-ii
5. https://leetcode.com/problems/reverse-nodes-in-k-group/
