(window.webpackJsonp=window.webpackJsonp||[]).push([[70],{309:function(n,e,t){"use strict";t.r(e);var r=t(0),a=Object(r.a)({},(function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[t("h2",{attrs:{id:"外键多了会有很多维护问题吧？"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#外键多了会有很多维护问题吧？","aria-hidden":"true"}},[n._v("#")]),n._v(" 外键多了会有很多维护问题吧？")]),n._v(" "),t("p",[n._v("2019-06-19\n 作者回复\n是否使用外键确实会有一些争议。我来解释下关于外键的使用：\n首先，外键本身是为了实现强一致性，所以如果需要正确性>性能的话，还是建议使用外键，它可以让我们在数据库的层面保证数据的完整性和一致性。\n当然不用外键，你也可以在业务层进行实现。不过，这样做也同样存在一定的风险，因为这样，就会让业务逻辑会与数据具备一定的耦合性。也就是业务逻辑和数据必须同时修改。而且在工作中，业务层可能会经常发生变化。")]),n._v(" "),t("p",[n._v("当然，很多互联网的公司，尤其是超大型的数据应用场景，大量的插入，更新和删除在外键的约束下会降低性能，同时数据库在水平拆分和分库的情况下，数据库端也做不到执行外键约束。另外，在高并发的情况下，外键的存在也会造成额外的开销。因为每次更新数据，都需要检查另外一张表的数据，也容易造成死锁。\n所以在这种情况下，尤其是大型项目中后期，可以采用业务层来实现，取消外键提高效率。\n不过在 SQL 学习之初，包括在系统最初设计的时候，还是建议你采用规范的数据库设计，也就是采用外键来对数据表进行约束。因为这样可以建立一个强一致性，可靠性高的数据库结构，也不需要在业务层来实现过多的检查。\n当然在项目后期，业务量增大的情况下，你需要更多考虑到数据库性能问题，可以取消外键的约束，转移到业务层来实现。而且在大型互联网项目中，考虑到分库分表的情况，也会降低外键的使用。\n不过在 SQL 学习，以及项目早期，还是建议你使用外键。在项目后期，你可以分析有哪些外键造成了过多的性能消耗。一般遵循 2/8 原则，会有 20%的外键造成 80%的资源效率，你可以只把这 20%的外键进行开放，采用业务层逻辑来进行实现，当然你需要保证业务层的实现没有错误。不同阶段，考虑的问题不同。当用户和业务量增大的时候，对于大型互联网应用，也会通过减少外键的使用，来减低死锁发生的概率，提高并发处理能力。")]),n._v(" "),t("h2",{attrs:{id:"关于-count-的效率是一个很好的问题，欢迎探讨："}},[t("a",{staticClass:"header-anchor",attrs:{href:"#关于-count-的效率是一个很好的问题，欢迎探讨：","aria-hidden":"true"}},[n._v("#")]),n._v(" 关于 COUNT()的效率是一个很好的问题，欢迎探讨：")]),n._v(" "),t("p",[n._v("在 MySQL InnoDB 存储引擎中，COUNT("),t("em",[n._v(")和 COUNT(1)都是对的所有结果进行的 COUNT。如果有 WHERE 子句，则是对所有符合筛选条件的数据行进行统计。如果没有 WHERE 子句，则是对数据表的数据行数进行统计。\n因此 COUNT(")]),n._v(")和 COUNT(1)本质上没有区别，执行的复杂度都是 O(N)，也就是采用全表扫描，进行循环+计数的方式进行统计。\n如果是 MySQL MyISAM 存储引擎，统计数据表的行数只需要 O(1)复杂度，这是因为每张 MyISAM 的数据表都有一个 meta 信息有存储了 row_count 值。而一致性由表级锁来保证。而 InnoDB 支持事务，采用行级锁和 MVCC 机制，所以无法像 MyISAM 一样，只维护一个 row_count 变量。因此就需要采用扫描全表，进行循环+计数的方式来完成统计。\n需要注意的是，在实际执行中 COUNT(*)和 COUNT(1)执行时间可能略有差别，不过你还是可以把这两个在执行效率上看成是相等的。")]),n._v(" "),t("p",[n._v("另外在 InnoDB 引擎中，如果是采用 COUNT("),t("em",[n._v(")和 COUNT(1)来统计数据行数，要尽量采用二级索引。\n因为主键采用的索引是聚簇索引，聚簇索引包含的信息多，明显会大于二级索引（非聚簇索引）。\n对于查找具体的行来说，采用主键索引效率更高。而对于 COUNT(")]),n._v(")和 COUNT(1)这种，不需要查找具体的行，只是统计行数来说，系统会自动采用占用空间更小的二级索引来进行统计。\n如果有多个二级索引的时候，会使用 key_len 小的二级索引进行扫描。当没有二级索引的时候，才会采用主键索引来进行统计。")]),n._v(" "),t("p",[n._v("优化总结：\n1、一般情况下：COUNT("),t("em",[n._v(") = COUNT(1) > COUNT(字段)\n所以尽量使用 COUNT(")]),n._v(")，当然如果你要统计的是就是某个字段的非空数据行数，那另当别论。毕竟执行效率比较的前提是要结果一样才行。\n2、如果要统计 COUNT("),t("em",[n._v(")，尽量在数据表上建立二级索引，系统会自动采用 key_len 小的二级索引进行扫描，这样当我们使用 SELECT COUNT(")]),n._v(")的时候效率就会提升，有时候提升几倍甚至更高都是有可能的。")]),n._v(" "),t("h2",{attrs:{id:"就是要避免全表扫描，所以我们会考虑在-where-及-order-by-涉及到的列上增加索引"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#就是要避免全表扫描，所以我们会考虑在-where-及-order-by-涉及到的列上增加索引","aria-hidden":"true"}},[n._v("#")]),n._v(" 就是要避免全表扫描，所以我们会考虑在 WHERE 及 ORDER BY 涉及到的列上增加索引")]),n._v(" "),t("p",[n._v("where 条件字段上加索引是可以明白的，但是为什么 order by 字段上还要加索引呢？这个时候已经通过 where 条件过滤得到了数据，已经不需要在筛选过滤数据了，只需要在排序的时候根据字段排序就好了。不是很明白\n2019-06-24\n 作者回复\n这是一个很好的问题，关于 ORDER BY 字段是否增加索引：\n在 MySQL 中，支持两种排序方式：FileSort 和 Index 排序。Index 排序的效率更高，\nIndex 排序：索引可以保证数据的有序性，因此不需要再进行排序。\nFileSort 排序：一般在内存中进行排序，占用 CPU 较多。如果待排结果较大，会产生临时文件 I/O 到磁盘进行排序，效率较低。")]),n._v(" "),t("p",[n._v("所以使用 ORDER BY 子句时，应该尽量使用 Index 排序，避免使用 FileSort 排序。\n当然具体优化器是否采用索引进行排序，你可以使用 explain 来进行执行计划的查看。\n优化建议：\n1、SQL 中，可以在 WHERE 子句和 ORDER BY 子句中使用索引，目的是在 WHERE 子句中避免全表扫描，ORDER BY 子句避免使用 FileSort 排序。\n当然，某些情况下全表扫描，或者 FileSort 排序不一定比索引慢。但总的来说，我们还是要避免，以提高查询效率。\n一般情况下，优化器会帮我们进行更好的选择，当然我们也需要建立合理的索引。\n2、尽量 Using Index 完成 ORDER BY 排序。\n如果 WHERE 和 ORDER BY 相同列就使用单索引列；如果不同使用联合索引。\n3、无法 Using Index 时，对 FileSort 方式进行调优。")])])}),[],!1,null,null,null);e.default=a.exports}}]);