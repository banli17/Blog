(window.webpackJsonp=window.webpackJsonp||[]).push([[31],{258:function(v,_,a){"use strict";a.r(_);var t=a(0),r=Object(t.a)({},(function(){var v=this,_=v.$createElement,a=v._self._c||_;return a("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[a("h1",{attrs:{id:"v8-工作原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#v8-工作原理","aria-hidden":"true"}},[v._v("#")]),v._v(" v8 工作原理")]),v._v(" "),a("h2",{attrs:{id:"垃圾回收"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#垃圾回收","aria-hidden":"true"}},[v._v("#")]),v._v(" 垃圾回收")]),v._v(" "),a("h3",{attrs:{id:"栈中的垃圾回收"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#栈中的垃圾回收","aria-hidden":"true"}},[v._v("#")]),v._v(" 栈中的垃圾回收")]),v._v(" "),a("p",[v._v("执行栈中有一个记录当前执行状态的指针（ESP)，指向栈顶的函数执行上下文，函数执行完成后，ESP 会下移，函数执行上下文就是无效内存了，如果调用新函数，这块内存会被覆盖掉，用来存放新函数的执行上下文。")]),v._v(" "),a("p",[v._v("所以说，当一个函数执行完后，JS 引擎会通过向下移动 ESP 来销毁该函数保存在栈中的执行上下文。")]),v._v(" "),a("h2",{attrs:{id:"堆中的垃圾回收"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#堆中的垃圾回收","aria-hidden":"true"}},[v._v("#")]),v._v(" 堆中的垃圾回收")]),v._v(" "),a("p",[v._v("堆中的垃圾回收，就用到了 JS 的垃圾回收器。")]),v._v(" "),a("p",[v._v("代际假说有两个特点：")]),v._v(" "),a("ol",[a("li",[v._v("大部分对象在内存中存在的时间很短。")]),v._v(" "),a("li",[v._v("不死的对象，会存活的更久。")])]),v._v(" "),a("p",[v._v("V8 将堆分为新生代和老生代两个区域，新生代存放生存时间短的对象，老生代存放生存时间长的对象。")]),v._v(" "),a("p",[v._v("新生区通常只支持 1-8M 容量，老生区支持的容量大。V8 分别堆这两个区使用了不同的垃圾回收器。")]),v._v(" "),a("ul",[a("li",[v._v("副垃圾回收器，负责新生代的垃圾回收。")]),v._v(" "),a("li",[v._v("主垃圾回收器，负责老生代的垃圾回收。")])]),v._v(" "),a("h3",{attrs:{id:"垃圾回收器工作流程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#垃圾回收器工作流程","aria-hidden":"true"}},[v._v("#")]),v._v(" 垃圾回收器工作流程")]),v._v(" "),a("p",[v._v("垃圾回收器的工作流程是一致的：")]),v._v(" "),a("ol",[a("li",[v._v("标记空间中活动对象和非活动对象。")]),v._v(" "),a("li",[v._v("回收非活动对象所占用的内存。即清理标记为非活动对象的内存。")]),v._v(" "),a("li",[v._v("内存整理，通常垃圾回收后，内存会变得不连续，有内存碎片。")])]),v._v(" "),a("h3",{attrs:{id:"副垃圾回收器"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#副垃圾回收器","aria-hidden":"true"}},[v._v("#")]),v._v(" 副垃圾回收器")]),v._v(" "),a("p",[v._v("副垃圾回收器主要负责新生区的垃圾回收，通常小的对象分配到这里。")]),v._v(" "),a("p",[v._v("新生代中用 Scavenge 算法来处理，即把新生区对半分为两个区域，一般是对象区域，一半是空闲区域。新加入的对象会存放在对象区域，当对象区域快满时，就需要一次垃圾回收。")]),v._v(" "),a("p",[v._v("垃圾回收过程中，首先标记对象区域中的垃圾，标记完成后，进行垃圾清理阶段，副垃圾回收器会把存活的对象复制到空闲区域，同时将它们有序的排列起来，所以这个复制过程相当于是内存整理。")]),v._v(" "),a("p",[v._v("复制完成后，对象区域和空闲区域进行反转，这种角色反转的操作能让新生代的两块内存可以无限重复使用下去。")]),v._v(" "),a("p",[v._v("因为 Scavenge 算法，每次要复制存活对象到空闲区域，复制需要时间成本，所以如果新生区空间太大，每次清理需要很长时间，为了执行效率，新生区会设置的比较小。")]),v._v(" "),a("p",[v._v("但是由于新生区空间不大，会很快被装满，所以 JS 引擎采用对象晋升策略，即经过两次垃圾回收还存活的对象，会被移动到老生区中。")]),v._v(" "),a("h3",{attrs:{id:"主垃圾回收器"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#主垃圾回收器","aria-hidden":"true"}},[v._v("#")]),v._v(" 主垃圾回收器")]),v._v(" "),a("p",[v._v("主垃圾回收器负责老生区的垃圾回收，除了新生区晋升的对象，一些大的对象也会直接分配到老生区，所以老生区中的对象有两个特点：占用空间大、存活时间长。")]),v._v(" "),a("p",[v._v("如果使用 Scavenge 算法，复制大对象会花很长时间，同时还会浪费一半的空间。所以主垃圾回收器采用的是"),a("code",[v._v("标记-清除(Mark-Sweep)")]),v._v("算法。")]),v._v(" "),a("ol",[a("li",[v._v("标记过程，从根元素开始，进行递归遍历，能到达的元素就标记为活动对象，没有到达的就是垃圾数据。")]),v._v(" "),a("li",[v._v("垃圾清除")])]),v._v(" "),a("p",[v._v("但是上面的"),a("code",[v._v("标记-清除")]),v._v("算法，如果多次执行后，会有大量的内存碎片，会导致大对象无法分配到足够的连续内存。所以有产生了一个新的算法"),a("code",[v._v("标记-整理(Mark-Compact)")]),v._v("，是直接将活动对象从开始进行排列，然后将边界后面的内存一次清空。")]),v._v(" "),a("h3",{attrs:{id:"全停顿"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#全停顿","aria-hidden":"true"}},[v._v("#")]),v._v(" 全停顿")]),v._v(" "),a("p",[v._v("JS 是运行在主线程上的，一旦执行垃圾回收算法，JS 脚本会停止执行，等待垃圾回收完毕后再恢复执行，这种行为叫做全停顿(Stop-The-World)。")]),v._v(" "),a("p",[v._v("如果堆中数据 1.5G，V8 清理垃圾的时间会超过 1s。这样会让应用的性能和响应能力下降。新生代小，影响不大，但是老生代就不能这样了，所以为了降低卡顿，V8 将标记过程分为一个个子标记过程，同时让垃圾回收标记和 JS 应用逻辑交替执行，直到标记阶段完成，这个算法叫"),a("code",[v._v("增量标记算法(Incremental Marking)")]),v._v("。")]),v._v(" "),a("p",[v._v("新生代和老生代的标记过程是同一过程，之后新生代把存活的数据移动到空闲区，老生代把死去的对象加到空闲列表中。")]),v._v(" "),a("p",[v._v("V8 还维护了一个空闲列表，也就是没有被使用的空闲空间列表，垃圾清理过程就是把没有标记的添加到空闲列表中！")]),v._v(" "),a("p",[v._v("增量标记会受到中间穿插的 js 应用逻辑影响么？会造成标记结果不全或者错误么？\n不全没关系，新产生的垃圾下次再回收，分配内存使用空闲列表里面的。")]),v._v(" "),a("h3",{attrs:{id:"怎么看内存泄露"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#怎么看内存泄露","aria-hidden":"true"}},[v._v("#")]),v._v(" 怎么看内存泄露")]),v._v(" "),a("ol",[a("li",[v._v("一般是感官上的长时间运行页面卡顿，猜可能会有内存泄漏。")]),v._v(" "),a("li",[v._v("使用 chrome 的 Performance 面板，观察内存变化 如何多次垃圾回收后，整体趋势是向上，就存在内部泄漏的可能！")]),v._v(" "),a("li",[v._v("确定不使用的临时变量置为 null，当前 es6 普及场景下少使用闭包也是一种方法。")])]),v._v(" "),a("h3",{attrs:{id:"可能导致内存泄露"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#可能导致内存泄露","aria-hidden":"true"}},[v._v("#")]),v._v(" 可能导致内存泄露")]),v._v(" "),a("ul",[a("li",[v._v("全局变量过大")]),v._v(" "),a("li",[v._v("定时器没有清除")]),v._v(" "),a("li",[v._v("闭包")]),v._v(" "),a("li",[v._v("DOM 引用")])])])}),[],!1,null,null,null);_.default=r.exports}}]);