// 守护进程的启动方式
// 1. 创建进程A。
// 2. 在进程A中创建进程B，可以使用fork或其它方式。
// 3. 对进程B执行 setsid 方法。
// 4. 进程A退出，进程B变成孤儿进程由1号进程(init进程)接管，此时B为守护进程。

// 1) 创建子进程，父进程退出
// 2) 创建会话
// 什么是进程组？
// 每个进程都属于一个进程组，进程组号是进程组组长的PID号，一个进程只能为自己或子进程设置组ID号。
// 会话期(session)是一个或多个进程组的集合。setsid可以创建一个会话起。
// 调用setsid的进程不是一个进程组的组长，此函数创建一个新的会话期。
// - 此进程变成对话期的首进程，变成新进程组的组长进程。调用setsid前如果有控制终端，则解除联系。如果该进程是组长，则函数返回错误。为了保证这点，先fork()再exit()。其实就是起到了进程脱离原会话的控制，摆脱了原进程组的控制，摆脱了原控制终端的控制。
// 那么为什么要调用setsid函数呢？主要是因为前面创建子进程的时候，随人父进程退出了，但是子进程拷贝了父进程的会话、进程组、控制终端等等，所以需要使用setsid来摆脱控制。
// 3)在fork子进程的时候，子进程也继承了父进程的工作目录。通常是让‘/’目录作为守护进程的当前目录，可以避免很多麻烦。
// 4)设置文件掩码: 同一个文件的权限掩码是一样的，我们使用fork创建的子进程会从父进程那里继承一些已经打开的文件，打开的文件可能永远不会被守护进程读写，但是他们一样消耗资源，而且可能导致所在的文件系统无法结束。
// ps -ef | grep dameon
// https://zhuanlan.zhihu.com/p/56840430
// 例如PM2中，将一个进程同时启动4次，达到CPU多核使用的目的（很有可能你的进程在同一核中运行），进程挂掉后自动重启等等，这些事情等着我们去造轮子。

// 编写守护进程
// 1)创建子进程，退出父进程
const child_process = require('child_process')

const p = child_process.spawn('node', ['server.js'], {
    detached: true    // 2) 调用setsid
})

console.log(process.pid, p.pid);

// 2) 退出父进程

process.exit(0)