## 外键多了会有很多维护问题吧？

2019-06-19
 作者回复
是否使用外键确实会有一些争议。我来解释下关于外键的使用：
首先，外键本身是为了实现强一致性，所以如果需要正确性>性能的话，还是建议使用外键，它可以让我们在数据库的层面保证数据的完整性和一致性。
当然不用外键，你也可以在业务层进行实现。不过，这样做也同样存在一定的风险，因为这样，就会让业务逻辑会与数据具备一定的耦合性。也就是业务逻辑和数据必须同时修改。而且在工作中，业务层可能会经常发生变化。

当然，很多互联网的公司，尤其是超大型的数据应用场景，大量的插入，更新和删除在外键的约束下会降低性能，同时数据库在水平拆分和分库的情况下，数据库端也做不到执行外键约束。另外，在高并发的情况下，外键的存在也会造成额外的开销。因为每次更新数据，都需要检查另外一张表的数据，也容易造成死锁。
所以在这种情况下，尤其是大型项目中后期，可以采用业务层来实现，取消外键提高效率。
不过在 SQL 学习之初，包括在系统最初设计的时候，还是建议你采用规范的数据库设计，也就是采用外键来对数据表进行约束。因为这样可以建立一个强一致性，可靠性高的数据库结构，也不需要在业务层来实现过多的检查。
当然在项目后期，业务量增大的情况下，你需要更多考虑到数据库性能问题，可以取消外键的约束，转移到业务层来实现。而且在大型互联网项目中，考虑到分库分表的情况，也会降低外键的使用。
不过在 SQL 学习，以及项目早期，还是建议你使用外键。在项目后期，你可以分析有哪些外键造成了过多的性能消耗。一般遵循 2/8 原则，会有 20%的外键造成 80%的资源效率，你可以只把这 20%的外键进行开放，采用业务层逻辑来进行实现，当然你需要保证业务层的实现没有错误。不同阶段，考虑的问题不同。当用户和业务量增大的时候，对于大型互联网应用，也会通过减少外键的使用，来减低死锁发生的概率，提高并发处理能力。

## 关于 COUNT()的效率是一个很好的问题，欢迎探讨：

在 MySQL InnoDB 存储引擎中，COUNT(_)和 COUNT(1)都是对的所有结果进行的 COUNT。如果有 WHERE 子句，则是对所有符合筛选条件的数据行进行统计。如果没有 WHERE 子句，则是对数据表的数据行数进行统计。
因此 COUNT(_)和 COUNT(1)本质上没有区别，执行的复杂度都是 O(N)，也就是采用全表扫描，进行循环+计数的方式进行统计。
如果是 MySQL MyISAM 存储引擎，统计数据表的行数只需要 O(1)复杂度，这是因为每张 MyISAM 的数据表都有一个 meta 信息有存储了 row_count 值。而一致性由表级锁来保证。而 InnoDB 支持事务，采用行级锁和 MVCC 机制，所以无法像 MyISAM 一样，只维护一个 row_count 变量。因此就需要采用扫描全表，进行循环+计数的方式来完成统计。
需要注意的是，在实际执行中 COUNT(\*)和 COUNT(1)执行时间可能略有差别，不过你还是可以把这两个在执行效率上看成是相等的。

另外在 InnoDB 引擎中，如果是采用 COUNT(_)和 COUNT(1)来统计数据行数，要尽量采用二级索引。
因为主键采用的索引是聚簇索引，聚簇索引包含的信息多，明显会大于二级索引（非聚簇索引）。
对于查找具体的行来说，采用主键索引效率更高。而对于 COUNT(_)和 COUNT(1)这种，不需要查找具体的行，只是统计行数来说，系统会自动采用占用空间更小的二级索引来进行统计。
如果有多个二级索引的时候，会使用 key_len 小的二级索引进行扫描。当没有二级索引的时候，才会采用主键索引来进行统计。

优化总结：
1、一般情况下：COUNT(_) = COUNT(1) > COUNT(字段)
所以尽量使用 COUNT(_)，当然如果你要统计的是就是某个字段的非空数据行数，那另当别论。毕竟执行效率比较的前提是要结果一样才行。
2、如果要统计 COUNT(_)，尽量在数据表上建立二级索引，系统会自动采用 key_len 小的二级索引进行扫描，这样当我们使用 SELECT COUNT(_)的时候效率就会提升，有时候提升几倍甚至更高都是有可能的。

## 就是要避免全表扫描，所以我们会考虑在 WHERE 及 ORDER BY 涉及到的列上增加索引

where 条件字段上加索引是可以明白的，但是为什么 order by 字段上还要加索引呢？这个时候已经通过 where 条件过滤得到了数据，已经不需要在筛选过滤数据了，只需要在排序的时候根据字段排序就好了。不是很明白
2019-06-24
 作者回复
这是一个很好的问题，关于 ORDER BY 字段是否增加索引：
在 MySQL 中，支持两种排序方式：FileSort 和 Index 排序。Index 排序的效率更高，
Index 排序：索引可以保证数据的有序性，因此不需要再进行排序。
FileSort 排序：一般在内存中进行排序，占用 CPU 较多。如果待排结果较大，会产生临时文件 I/O 到磁盘进行排序，效率较低。

所以使用 ORDER BY 子句时，应该尽量使用 Index 排序，避免使用 FileSort 排序。
当然具体优化器是否采用索引进行排序，你可以使用 explain 来进行执行计划的查看。
优化建议：
1、SQL 中，可以在 WHERE 子句和 ORDER BY 子句中使用索引，目的是在 WHERE 子句中避免全表扫描，ORDER BY 子句避免使用 FileSort 排序。
当然，某些情况下全表扫描，或者 FileSort 排序不一定比索引慢。但总的来说，我们还是要避免，以提高查询效率。
一般情况下，优化器会帮我们进行更好的选择，当然我们也需要建立合理的索引。
2、尽量 Using Index 完成 ORDER BY 排序。
如果 WHERE 和 ORDER BY 相同列就使用单索引列；如果不同使用联合索引。
3、无法 Using Index 时，对 FileSort 方式进行调优。
