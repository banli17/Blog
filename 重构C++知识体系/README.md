---
title: C++语言
sidebar_label: C++
---

优点：

1. 抽象封装能力强大
2. 高性能
3. 低功耗，适用于嵌入式

应用

1. 大型桌面应用程序，如 google chrome, microsoft office
2. 大型网站的后台，如 Google 的搜索引擎
3. 游戏和游戏引擎(如 Unity)
4. 视觉库和 AI 引擎(如 Opencv 和 Tensorflow)
5. 数据库(SQL Server 和 Mongodb)
6. 其它(如自动驾驶、嵌入式开发)

总结：C++开发成本高，适合用在对内存和 CPU 要很高、低功耗并且程序被调用非常频繁等场景中。

编程语言的层次和类型：

- 机器语言，汇编语言(移植性差)等
- 编译型语言，如 C++，C 等，编译成不同平台的语言
- 解释型语言 basic，python 等，通过解释器跨平台
- 脚本语言，如 bash，csh 等

编译型语言一般需要经历编译和链接的过程，才能变成真正可执行的程序。

![](imgs/2020-09-21-00-04-41.png)

![](imgs/2020-09-21-00-05-19.png)

https://medium.com/jspoint/a-simple-guide-to-load-c-c-code-into-node-js-javascript-applications-3fcccf54fd32

## 2. C++基础语法

### 2.1 编译型语言

![](imgs/2020-10-23-15-09-05.png)

脚本语言 - 边解释边执行
非脚本语言 - 编译后执行

编译型语言一般需要经历编译和链接的过程，才能编程真正可执行的程序。
![](imgs/2020-10-23-15-15-22.png)
动态程序一般有两种实现方式，一是二进制方式，一是脚本方式。 二进制方式是先将我们编写的程序进行编译，变成机器可识别的指令代码（如.exe 文件），然后再执行。这种编译好的程序我们只能执行、使用，却看不到他的程序内容。脚本简单地说就是一条条的文字命令，这些文字命令是我们可以看到的（如可以用记事本打开查看、编辑），脚本程序在执行时，是由系统的一个解释器，将其一条条的翻译成机器可识别的指令，并按程序顺序执行。因为脚本在执行时多了一道翻译的过程，所以它比二进制程序执行效率要稍低一些。
script 的原意是“手写的，区别于印刷的东西”。即可修改。

### 2.2 数据类型

![](imgs/2020-10-23-15-23-58.png)
![](imgs/2020-10-23-15-25-51.png)
![](imgs/2020-10-23-15-28-12.png)
![](imgs/2020-10-23-15-29-24.png)
![](imgs/2020-10-23-15-31-53.png)
![](imgs/2020-10-23-15-33-04.png)

宽字节是用 2 个字节来表示一个字符。

### 标识符与关键字

标识符规则

- 开头：`[a-zA-Z_]`，后面可以是 `[a-zA-Z0-9_]`
- 不能数字开头、不能有 @ & %
- 区分大小写
- 不能用关键字，原则上长度不超过 32 位

常见的关键字
![](imgs/2020-10-19-16-54-40.png)

一些新的 keyword
![](imgs/2020-10-19-16-55-58.png)

所有 keyword: https://en.cppreference.com/w/cpp/keyword

原则：

- 符合团队项目规范
- 见名知意
- `min-length&max-infomation`原则
- 变量名采用名词或形容词+名词。避免出现数字，如 value1。函数采用动词+名词
- 命名法
  - 微软匈牙利命名法: int iMaxAge，首字母是类型缩写，后续为名称，名称的首字母大写
  - 驼峰 camel: int maxAge
  - pascal 命名法: int MaxAge

### 变量和常量

```
// 变量
int m = 1;
```

常量的定义方法：

- #define, 如 #define PI 3.14，(不推荐，编译期间不会报错)
- const, 如 const double PI = 3.14，(推荐，编译期间会报错)

- #define 和 const 的区别?

整数常量: 可以是十进制、八进制(0 开头)、十六进制(0x 或 0X 开头)的常量。
整数常量也可以带一个后缀，后缀是 U 和 L 的组合，U 表示无符号整数 unsigned，L 表示 long 长整数，后缀不区分大小写和顺序。

![](imgs/2020-10-19-17-18-07.png)

布尔常量

- true
- false

字符常量：单引号，
![](imgs/2020-10-19-17-19-14.png)
宽字符 2 个字节，没有 L 是一个字节
![](imgs/2020-10-19-17-20-10.png)

### 运算符表达式

![](imgs/2020-10-19-17-26-21.png)
![](imgs/2020-10-19-17-27-46.png)

算术运算符

![](imgs/2020-10-20-09-36-41.png)

![](imgs/2020-10-20-09-39-43.png)

## 3. C++的运算符与表达式

cout cin 在 iostream 库下，C++ 预定义了标准的输入输出流设备，键盘和屏幕。可以更改输入输出设备。endl 是换行。

```c++
#include "iostream"

using namespace std;  // 如果找不到的变量或方法，会在命名空间下查找
int main() {
    int a = -10;
    cout << a << endl;
    cout << "hello world";
}
```

### 3.2 - 3.7 运算符表达式

![](imgs/2020-10-23-09-35-07.png)
![](imgs/2020-10-23-09-35-30.png)
![](imgs/2020-10-23-09-34-49.png)
![](imgs/2020-10-23-09-36-34.png)
![](imgs/2020-10-23-10-58-29.png)
![](imgs/2020-10-23-12-03-59.png)
![](imgs/2020-10-23-12-04-46.png)
![](imgs/2020-10-23-12-42-00.png)

```c++
#include <assert.h>
```

![](imgs/2020-10-23-13-01-32.png)
![](imgs/2020-10-23-13-02-28.png)

![](imgs/2020-10-23-14-33-39.png)
![](imgs/2020-10-23-14-35-29.png)
![](imgs/2020-10-23-14-47-33.png)
^ 异或 ～非
![](imgs/2020-10-23-14-56-49.png)

sizeof 返回的是占用的大小，整数占 4 个字节。字符占一个字节。

![](imgs/2020-10-23-15-03-36.png)

结构体
![](imgs/2020-10-23-15-04-22.png)
![](imgs/2020-10-23-15-07-20.png)

### 3.8 注释

代码的解释、提高源代码的可读性
单行注释、多行注释，注释中的字符会被 C++ 编译器忽略。

```
//
/**/
```

在注释里使用 `//`或`/**/`，它只被作为注释内容。

1. 好的命名和代码本身就是最好的注释，无需添加额外的注释。注释并不是越多越好。
2. 重要复杂代码段，先写注释、再写代码，保证两者的一致性
3. 如果更新了代码，也相应更新注释

### 3.10 - 3.12 补码

无符号数在计算机中是以机器码存的。
有符号数，正数是机器码，负数是补码。

32 位计算机用 4 byte 来表示一个字符。

真值：就是 10 进制的数。
补码转真值的计算公式:
第一种方法：

```
10000001 -> -1 * 2^7 + ... + 1 * 2 ^ 0
```

第二种方法：
机器码的反码 +1，就是补码

内存查看器为了简化、方便表示，用了 16 进制来表示。

补码数值的范围：在 16 进制，有符号最大是 0x80000000(-2147483648)，最小是 0x7fffffff(2147483647)。

字节序的表示方法有 2 种：

- 大端法：大多数 IBM 机器(在内存中是正序)
- 小端法：Intel 兼容机(个人机器)(在内存中是倒序)

比如 10 的机器码是 00 00 00 0a，但在内存中是小端法表示的。

![](imgs/2020-10-22-02-22-12.png)

**关于位移操作的说明**

- 左移操作: 低位补 0
- 右移操作: 有符号数，移动有 2 种方式
  - 逻辑移位，最高位是补 0
  - 算术移位，负数最高位是补 1。
  - 因为不同的机器采用的方式可能不同，所以负数右移可能会产生 bug，应该避免负数右移

## 第 4 章 C++基础容器

### 4.1 - 4.5 数组

![](imgs/2020-10-24-15-01-25.png)
![](imgs/2020-10-24-15-07-40.png)

思考：x>=11 x<=21 有多少个数？转为左闭，右开的区间 [11, 22) ，然后作减法 22 - 11 = 11

所以 for 循环这样写：

```
for(int i = 0; i< 10;i++){}
```

![](imgs/2020-10-24-15-57-16.png)
![](imgs/2020-10-24-16-05-04.png)

数组越大，移动时间越长。

数组的访问： O(1)
![](imgs/2020-10-24-16-07-43.png)
![](imgs/2020-10-24-16-28-58.png)
![](imgs/2020-10-24-16-36-18.png)

![](imgs/2020-10-24-16-43-18.png)
![](imgs/2020-10-24-16-44-18.png)
![](imgs/2020-10-24-16-46-57.png)

C、C++中没有提供 直接获取数组长度的函数，对于存放字符串的字符数组提供了一个 strlen 函数获取长度，那么对于其他类型的数组如何获取他们的长度呢？其中一种方法是使 用`sizeof(array) / sizeof(array[0])`, 在 C 语言中习惯上在 使用时都把它定义成一个宏，比如`#define GET_ARRAY_LEN(array,len) {len = (sizeof(array) / sizeof(array[0]));}` 。而在 C++中则可以使用模板 技术定义一个函数，比如：

```c++
template <class T>

int getArrayLen(T& array)

{
return (sizeof(array) / sizeof(array[0]));

}
```

若数组为存储 字符串的字符数组，则所求得的长度还需要减一,原因为存储字符串的字 符数组末尾有一个'\0'字符，需要去掉它。
![](imgs/2020-10-24-23-09-44.png)
![](imgs/2020-10-24-23-13-04.png)
![](imgs/2020-10-24-23-12-50.png)

插入元素：

```
vec.insert(vec.begin() + 1, 6) // 往 begin + 1 后插入，即第2个元素
vec.insert(vec.end(), 6)  // 往 end 前插入，即最后
```

end 是末尾+1 的位置，即结束符。

## 第 5 章 彻底学会 C++ 指针，引用

## 第 6 章 C++基础句法

## 第 7 章 C++高级语法

## 第 8 章 C++编程思想

## 第 9 章 C++进阶编程

## 第 10 章 桌面应用项目实战：设计项目的架构和标准

## 第 11 章 实现项目《慕影》的通用组件模块

## 第 12 章 《慕影》播放器 UI 模块开发

## 第 13 章 实现《慕影》音视频模块开发

## 第 14 章 《慕影》播放器项目总结

## 15

![](imgs/2020-10-20-17-56-24.png)
